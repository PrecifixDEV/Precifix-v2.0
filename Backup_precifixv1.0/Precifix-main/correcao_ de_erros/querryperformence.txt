# Informações do supabase sobre querry performance:

[
  {
    "query": "SELECT name FROM pg_timezone_names",
    "rolname": "authenticator",
    "calls": 175,
    "mean_time": 291.850656634286,
    "min_time": 52.511262,
    "max_time": 990.972763,
    "total_time": 51073.864911,
    "rows_read": 208950,
    "cache_hit_rate": "0",
    "prop_total_time": 30.102021478474455,
    "index_advisor_result": null
  },
  {
    "query": "WITH table_info AS (\n            SELECT\n                tables.table_name,\n                pd.description as table_description\n            FROM information_schema.tables tables\n            LEFT JOIN pg_stat_user_tables psut ON tables.table_name = psut.relname\n            LEFT JOIN pg_description pd ON psut.relid = pd.objoid AND pd.objsubid = $1\n            WHERE tables.table_schema = $2\n        ),\n        column_info AS (\n            SELECT\n                c.table_name,\n                jsonb_agg(\n                    jsonb_build_object(\n                        $3, c.column_name,\n                        $4, c.data_type,\n                        $5, c.is_nullable,\n                        $6, c.column_default\n                    ) ORDER BY c.ordinal_position\n                ) as columns\n            FROM information_schema.columns c\n            WHERE c.table_schema = $7\n            GROUP BY c.table_name\n        ),\n        tables_result AS (\n            SELECT\n                $8 as result_type,\n                jsonb_build_object(\n                    $9, ti.table_name::text,\n                    $10, ti.table_description::text,\n                    $11, COALESCE(ci.columns, $12::jsonb)\n                )::text as data\n            FROM table_info ti\n            LEFT JOIN column_info ci ON ti.table_name = ci.table_name\n        ),\n        policies_result AS (\n            SELECT\n                $13 as result_type,\n                jsonb_build_object(\n                    $14, pol.polname::text,\n                    $15, cls.relname::text,\n                    $16, CASE\n                        WHEN pol.polcmd = $17 THEN $18\n                        WHEN pol.polcmd = $19 THEN $20\n                        WHEN pol.polcmd = $21 THEN $22\n                        WHEN pol.polcmd = $23 THEN $24\n                        ELSE pol.polcmd::text\n                    END,\n                    $25, pol.polpermissive,\n                    $26, pg_get_expr(pol.polqual, pol.polrelid)::text\n                )::text as data\n            FROM pg_policy pol\n            JOIN pg_class cls ON pol.polrelid = cls.oid\n            WHERE cls.relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = $27)\n        ),\n        functions_result AS (\n            SELECT\n                $28 as result_type,\n                jsonb_build_object(\n                    $29, p.proname::text,\n                    $30, d.description::text,\n                    $31, pg_get_function_arguments(p.oid)::text,\n                    $32, pg_get_function_result(p.oid)::text,\n                    $33, l.lanname::text,\n                    $34, CASE p.provolatile\n                        WHEN $35 THEN $36\n                        WHEN $37 THEN $38\n                        WHEN $39 THEN $40\n                    END,\n                    $41, pg_get_functiondef(p.oid)::text\n                )::text as data\n            FROM pg_proc p\n            LEFT JOIN pg_description d ON p.oid = d.objoid\n            LEFT JOIN pg_language l ON p.prolang = l.oid\n            WHERE p.pronamespace = (SELECT oid FROM pg_namespace WHERE nspname = $42) AND p.prokind = $43 -- 'f' = normal function (otherwise source code fetch fails)\n        ),\n        triggers_result AS (\n            SELECT\n                $44 as result_type,\n                jsonb_build_object(\n                    $45, t.trigger_name::text,\n                    $46, t.event_object_table::text,\n                    $47, t.action_timing::text,\n                    $48, t.event_manipulation::text,\n                    $49, t.action_statement::text,\n                    $50, p.proname::text\n                )::text as data\n            FROM information_schema.triggers t\n            LEFT JOIN pg_trigger pg_t ON t.trigger_name = pg_t.tgname\n            LEFT JOIN pg_proc p ON pg_t.tgfoid = p.oid\n            WHERE t.trigger_schema = $51\n        )\n        SELECT result_type, data\n        FROM (\n            SELECT * FROM tables_result\n            UNION ALL SELECT * FROM policies_result\n            UNION ALL SELECT * FROM functions_result\n            UNION ALL SELECT * FROM triggers_result\n        ) combined_results\n        ORDER BY result_type",
    "rolname": "postgres",
    "calls": 2560,
    "mean_time": 13.4505510304687,
    "min_time": 2.659461,
    "max_time": 257.448443,
    "total_time": 34433.4106380001,
    "rows_read": 176129,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 20.294435684638607,
    "index_advisor_result": null
  },
  {
    "query": "with f as (\n      \n-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    *,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n  where\n    p.prokind = $5\n)\nselect\n  f.oid as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $6 then $7\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $8 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $9) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid, $10) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.provolatile = $11 then $12\n    when f.provolatile = $13 then $14\n    when f.provolatile = $15 then $16\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $17))[$18] as param,\n          (string_to_array(unnest(proconfig), $19))[$20] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $21, t2.mode,\n        $22, name,\n        $23, type_id,\n        -- Cast null into false boolean\n        $24, COALESCE(has_default, $25)\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume\n          -- integer, we need to cast it to be properly parsed\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $26 then $27\n            when t1.mode = $28 then $29\n            when t1.mode = $30 then $31\n            when t1.mode = $32 then $33\n            else $34\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid\n\n    )\n    select\n      f.*\n    from f\n   where schema NOT IN ($35,$36,$37)\n\n-- source: dashboard\n-- user: f4c37f98-b189-4586-b8c3-92b3e328aedf\n-- date: 2025-10-13T20:10:52.547Z",
    "rolname": "postgres",
    "calls": 106,
    "mean_time": 132.514998075472,
    "min_time": 73.463062,
    "max_time": 851.870418,
    "total_time": 14046.589796,
    "rows_read": 12986,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 8.27880851537917,
    "index_advisor_result": null
  },
  {
    "query": "select set_config('search_path', $1, true), set_config($2, $3, true), set_config('role', $4, true), set_config('request.jwt.claims', $5, true), set_config('request.method', $6, true), set_config('request.path', $7, true), set_config('request.headers', $8, true), set_config('request.cookies', $9, true)",
    "rolname": "authenticated",
    "calls": 82962,
    "mean_time": 0.121718669137677,
    "min_time": 0.014187,
    "max_time": 167.915599,
    "total_time": 10098.024229,
    "rows_read": 82962,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 5.951594670996711,
    "index_advisor_result": null
  },
  {
    "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND\n      \n      c.contype = $19\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($20) AND\n  \n  \n  c.relkind IN ($21, $22)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $23)\n    OR has_table_privilege(\n      c.oid,\n      $24\n    )\n    OR has_any_column_privilege(c.oid, $25)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  \nselect\n  *\n  \nfrom tables",
    "rolname": "postgres",
    "calls": 238,
    "mean_time": 31.4406140588235,
    "min_time": 3.997296,
    "max_time": 598.165769,
    "total_time": 7482.866146,
    "rows_read": 3574,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 4.410267322434971,
    "index_advisor_result": null
  },
  {
    "query": "WITH table_info AS (\n            SELECT\n                tables.table_name,\n                pd.description as table_description,\n                cls.relrowsecurity as rls_enabled\n            FROM information_schema.tables tables\n            LEFT JOIN pg_stat_user_tables psut ON tables.table_name = psut.relname\n            LEFT JOIN pg_class cls ON psut.relid = cls.oid\n            LEFT JOIN pg_description pd ON psut.relid = pd.objoid AND pd.objsubid = $1\n            WHERE tables.table_schema = $2\n        ),\n        column_info AS (\n            SELECT\n                c.table_name,\n                jsonb_agg(\n                    jsonb_build_object(\n                        $3, c.column_name,\n                        $4, c.data_type,\n                        $5, c.is_nullable,\n                        $6, c.column_default\n                    ) ORDER BY c.ordinal_position\n                ) as columns\n            FROM information_schema.columns c\n            WHERE c.table_schema = $7\n            GROUP BY c.table_name\n        ),\n        tables_result AS (\n            SELECT\n                $8 as result_type,\n                jsonb_build_object(\n                    $9, ti.table_name::text,\n                    $10, ti.table_description::text,\n                    $11, ti.rls_enabled,\n                    $12, COALESCE(ci.columns, $13::jsonb)\n                )::text as data\n            FROM table_info ti\n            LEFT JOIN column_info ci ON ti.table_name = ci.table_name\n        ),\n        policies_result AS (\n            SELECT\n                $14 as result_type,\n                jsonb_build_object(\n                    $15, pol.polname::text,\n                    $16, cls.relname::text,\n                    $17, CASE\n                        WHEN pol.polcmd = $18 THEN $19\n                        WHEN pol.polcmd = $20 THEN $21\n                        WHEN pol.polcmd = $22 THEN $23\n                        WHEN pol.polcmd = $24 THEN $25\n                        ELSE pol.polcmd::text\n                    END,\n                    $26, pol.polpermissive,\n                    $27, pg_get_expr(pol.polqual, pol.polrelid)::text,\n                    $28, pg_get_expr(pol.polwithcheck, pol.polrelid)::text\n                )::text as data\n            FROM pg_policy pol\n            JOIN pg_class cls ON pol.polrelid = cls.oid\n            WHERE cls.relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = $29)\n        ),\n        functions_result AS (\n            SELECT\n                $30 as result_type,\n                jsonb_build_object(\n                    $31, p.proname::text,\n                    $32, d.description::text,\n                    $33, pg_get_function_arguments(p.oid)::text,\n                    $34, pg_get_function_result(p.oid)::text,\n                    $35, l.lanname::text,\n                    $36, CASE p.provolatile\n                        WHEN $37 THEN $38\n                        WHEN $39 THEN $40\n                        WHEN $41 THEN $42\n                    END,\n                    $43, pg_get_functiondef(p.oid)::text\n                )::text as data\n            FROM pg_proc p\n            LEFT JOIN pg_description d ON p.oid = d.objoid\n            LEFT JOIN pg_language l ON p.prolang = l.oid\n            WHERE p.pronamespace = (SELECT oid FROM pg_namespace WHERE nspname = $44) AND p.prokind = $45 -- 'f' = normal function (otherwise source code fetch fails)\n        ),\n        triggers_result AS (\n            SELECT\n                $46 as result_type,\n                jsonb_build_object(\n                    $47, t.trigger_name::text,\n                    $48, t.event_object_table::text,\n                    $49, t.action_timing::text,\n                    $50, t.event_manipulation::text,\n                    $51, t.action_statement::text,\n                    $52, p.proname::text\n                )::text as data\n            FROM information_schema.triggers t\n            LEFT JOIN pg_trigger pg_t ON t.trigger_name = pg_t.tgname\n            LEFT JOIN pg_proc p ON pg_t.tgfoid = p.oid\n            WHERE t.trigger_schema = $53\n        )\n        SELECT result_type, data\n        FROM (\n            SELECT * FROM tables_result\n            UNION ALL SELECT * FROM policies_result\n            UNION ALL SELECT * FROM functions_result\n            UNION ALL SELECT * FROM triggers_result\n        ) combined_results\n        ORDER BY result_type",
    "rolname": "postgres",
    "calls": 202,
    "mean_time": 32.5455572970297,
    "min_time": 8.625383,
    "max_time": 248.62643,
    "total_time": 6574.202574,
    "rows_read": 17870,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 3.874717283120044,
    "index_advisor_result": null
  },
  {
    "query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $3), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $4), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $5\n),\narguments AS (\n  SELECT\n    oid,\n    array_agg((\n      COALESCE(name, $6), -- name\n      type::regtype::text, -- type\n      CASE type\n        WHEN $7::regtype THEN $8\n        WHEN $9::regtype THEN $10\n        WHEN $11::regtype THEN $12\n        WHEN $13::regtype THEN $14\n        ELSE type::regtype::text\n      END, -- convert types that ignore the length and accept any value till maximum size\n      idx <= (pronargs - pronargdefaults), -- is_required\n      COALESCE(mode = $15, $16) -- is_variadic\n    ) ORDER BY idx) AS args,\n    CASE COUNT(*) - COUNT(name) -- number of unnamed arguments\n      WHEN $17 THEN $18\n      WHEN $19 THEN (array_agg(type))[$20] IN ($21::regtype, $22::regtype, $23::regtype, $24::regtype, $25::regtype)\n      ELSE $26\n    END AS callable\n  FROM pg_proc,\n       unnest(proargnames, proargtypes, proargmodes)\n         WITH ORDINALITY AS _ (name, type, mode, idx)\n  WHERE type IS NOT NULL -- only input arguments\n  GROUP BY oid\n)\nSELECT\n  pn.nspname AS proc_schema,\n  p.proname AS proc_name,\n  d.description AS proc_description,\n  COALESCE(a.args, $27) AS args,\n  tn.nspname AS schema,\n  COALESCE(comp.relname, t.typname) AS name,\n  p.proretset AS rettype_is_setof,\n  (t.typtype = $28\n   -- if any TABLE, INOUT or OUT arguments present, treat as composite\n   or COALESCE(proargmodes::text[] && $29, $30)\n  ) AS rettype_is_composite,\n  bt.oid <> bt.base_type as rettype_is_composite_alias,\n  p.provolatile,\n  p.provariadic > $31 as hasvariadic,\n  lower((regexp_split_to_array((regexp_split_to_array(iso_config, $32))[$33], $34))[$35]) AS transaction_isolation_level,\n  coalesce(func_settings.kvs, $36) as kvs\nFROM pg_proc p\nLEFT JOIN arguments a ON a.oid = p.oid\nJOIN pg_namespace pn ON pn.oid = p.pronamespace\nJOIN base_types bt ON bt.oid = p.prorettype\nJOIN pg_type t ON t.oid = bt.base_type\nJOIN pg_namespace tn ON tn.oid = t.typnamespace\nLEFT JOIN pg_class comp ON comp.oid = t.typrelid\nLEFT JOIN pg_description as d ON d.objoid = p.oid AND d.classoid = $37::regclass\nLEFT JOIN LATERAL unnest(proconfig) iso_config ON iso_config LIKE $38\nLEFT JOIN LATERAL (\n  SELECT\n    array_agg(row(\n      substr(setting, $39, strpos(setting, $40) - $41),\n      substr(setting, strpos(setting, $42) + $43)\n    )) as kvs\n  FROM unnest(proconfig) setting\n  WHERE setting ~ ANY($2)\n) func_settings ON $44\nWHERE t.oid <> $45::regtype AND COALESCE(a.callable, $46)\nAND prokind = $47\nAND p.pronamespace = ANY($1::regnamespace[])",
    "rolname": "authenticator",
    "calls": 175,
    "mean_time": 34.8669063028572,
    "min_time": 17.882712,
    "max_time": 267.23302,
    "total_time": 6101.708603,
    "rows_read": 325,
    "cache_hit_rate": "99.9659010784506375",
    "prop_total_time": 3.5962377968255104,
    "index_advisor_result": null
  },
  {
    "query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $2), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $3), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $4\n),\ncolumns AS (\n    SELECT\n        c.oid AS relid,\n        a.attname::name AS column_name,\n        d.description AS description,\n        -- typbasetype and typdefaultbin handles `CREATE DOMAIN .. DEFAULT val`,  attidentity/attgenerated handles generated columns, pg_get_expr gets the default of a column\n        CASE\n          WHEN (t.typbasetype != $5) AND (ad.adbin IS NULL) THEN pg_get_expr(t.typdefaultbin, $6)\n          WHEN a.attidentity  = $7 THEN format($8, seq.objid::regclass)\n          WHEN a.attgenerated = $9 THEN $10\n          ELSE pg_get_expr(ad.adbin, ad.adrelid)::text\n        END AS column_default,\n        not (a.attnotnull OR t.typtype = $11 AND t.typnotnull) AS is_nullable,\n        CASE\n            WHEN t.typtype = $12 THEN\n            CASE\n                WHEN bt.base_namespace = $13::regnamespace THEN format_type(bt.base_type, $14::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n            ELSE\n            CASE\n                WHEN t.typnamespace = $15::regnamespace THEN format_type(a.atttypid, $16::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n        END::text AS data_type,\n        format_type(a.atttypid, a.atttypmod)::text AS nominal_data_type,\n        information_schema._pg_char_max_length(\n            information_schema._pg_truetypid(a.*, t.*),\n            information_schema._pg_truetypmod(a.*, t.*)\n        )::integer AS character_maximum_length,\n        bt.base_type,\n        a.attnum::integer AS position\n    FROM pg_attribute a\n        LEFT JOIN pg_description AS d\n            ON d.objoid = a.attrelid and d.objsubid = a.attnum and d.classoid = $17::regclass\n        LEFT JOIN pg_attrdef ad\n            ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum\n        JOIN pg_class c\n            ON a.attrelid = c.oid\n        JOIN pg_type t\n            ON a.atttypid = t.oid\n        LEFT JOIN base_types bt\n            ON t.oid = bt.oid\n        LEFT JOIN pg_depend seq\n            ON seq.refobjid = a.attrelid and seq.refobjsubid = a.attnum and seq.deptype = $18\n    WHERE\n        NOT pg_is_other_temp_schema(c.relnamespace)\n        AND a.attnum > $19\n        AND NOT a.attisdropped\n        AND c.relkind in ($20, $21, $22, $23, $24)\n        AND c.relnamespace = ANY($1::regnamespace[])\n),\ncolumns_agg AS (\n  SELECT\n    relid,\n    array_agg(row(\n      column_name,\n      description,\n      is_nullable::boolean,\n      data_type,\n      nominal_data_type,\n      character_maximum_length,\n      column_default,\n      coalesce(\n        (SELECT array_agg(enumlabel ORDER BY enumsortorder) FROM pg_enum WHERE enumtypid = base_type),\n        $25\n      )\n    ) order by position) as columns\n  FROM columns\n  GROUP BY relid\n),\ntbl_pk_cols AS (\n  SELECT\n    r.oid AS relid,\n    array_agg(a.attname ORDER BY a.attname) AS pk_cols\n  FROM pg_class r\n  JOIN pg_constraint c\n    ON r.oid = c.conrelid\n  JOIN pg_attribute a\n    ON a.attrelid = r.oid AND a.attnum = ANY (c.conkey)\n  WHERE\n    c.contype in ($26)\n    AND r.relkind IN ($27, $28)\n    AND r.relnamespace NOT IN ($29::regnamespace, $30::regnamespace)\n    AND NOT pg_is_other_temp_schema(r.relnamespace)\n    AND NOT a.attisdropped\n  GROUP BY r.oid\n)\nSELECT\n  n.nspname AS table_schema,\n  c.relname AS table_name,\n  d.description AS table_description,\n  c.relkind IN ($31,$32) as is_view,\n  (\n    c.relkind IN ($33,$34)\n    OR (\n      c.relkind in ($35,$36)\n      -- The function `pg_relation_is_updateable` returns a bitmask where 8\n      -- corresponds to `1 << CMD_INSERT` in the PostgreSQL source code, i.e.\n      -- it's possible to insert into the relation.\n      AND (pg_relation_is_updatable(c.oid::regclass, $37) & $38) = $39\n    )\n  ) AS insertable,\n  (\n    c.relkind IN ($40,$41)\n    OR (\n      c.relkind in ($42,$43)\n      -- CMD_UPDATE\n      AND (pg_relation_is_updatable(c.oid::regclass, $44) & $45) = $46\n    )\n  ) AS updatable,\n  (\n    c.relkind IN ($47,$48)\n    OR (\n      c.relkind in ($49,$50)\n      -- CMD_DELETE\n      AND (pg_relation_is_updatable(c.oid::regclass, $51) & $52) = $53\n    )\n  ) AS deletable,\n  coalesce(tpks.pk_cols, $54) as pk_cols,\n  coalesce(cols_agg.columns, $55) as columns\nFROM pg_class c\nJOIN pg_namespace n ON n.oid = c.relnamespace\nLEFT JOIN pg_description d on d.objoid = c.oid and d.objsubid = $56 and d.classoid = $57::regclass\nLEFT JOIN tbl_pk_cols tpks ON c.oid = tpks.relid\nLEFT JOIN columns_agg cols_agg ON c.oid = cols_agg.relid\nWHERE c.relkind IN ($58,$59,$60,$61,$62)\nAND c.relnamespace NOT IN ($63::regnamespace, $64::regnamespace)\nAND not c.relispartition\nORDER BY table_schema, table_name",
    "rolname": "authenticator",
    "calls": 175,
    "mean_time": 29.0457339085714,
    "min_time": 1.120022,
    "max_time": 340.728171,
    "total_time": 5083.003434,
    "rows_read": 7465,
    "cache_hit_rate": "99.9704024488079197",
    "prop_total_time": 2.9958312105820935,
    "index_advisor_result": null
  },
  {
    "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      c.contype = $16\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  c.relkind IN ($17, $18)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $19)\n    OR has_table_privilege(\n      c.oid,\n      $20\n    )\n    OR has_any_column_privilege(c.oid, $21)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $22 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $23\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $24 THEN CASE\n      WHEN bt.typelem <> $25 :: oid\n      AND bt.typlen = $26 THEN $27\n      WHEN nbt.nspname = $28 THEN format_type(t.typbasetype, $29)\n      ELSE $30\n    END\n    ELSE CASE\n      WHEN t.typelem <> $31 :: oid\n      AND t.typlen = $32 THEN $33\n      WHEN nt.nspname = $34 THEN format_type(a.atttypid, $35)\n      ELSE $36\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($37, $38) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $39 THEN $40\n    WHEN $41 THEN $42\n    ELSE $43\n  END AS identity_generation,\n  a.attgenerated IN ($44) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $45 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($46, $47)\n    OR c.relkind IN ($48, $49) AND pg_column_is_updatable(c.oid, a.attnum, $50)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $51\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$52] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $53 AND cardinality(conkey) = $54\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$55] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $56),\n        $57,\n        length(pg_get_constraintdef(pg_constraint.oid, $58)) - $59\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $60 AND cardinality(conkey) = $61\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $62\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($63, $64, $65, $66, $67))\n  AND (\n    pg_has_role(c.relowner, $68)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $69\n    )\n  )\n)\n  select\n    *\n    , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $70\n) AS columns\n  from tables where name = $71 and schema = $72",
    "rolname": "postgres",
    "calls": 64,
    "mean_time": 68.5601565625,
    "min_time": 45.269244,
    "max_time": 234.345297,
    "total_time": 4387.85002,
    "rows_read": 64,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 2.5861202353988535,
    "index_advisor_result": null
  },
  {
    "query": "do $$\n    declare\n        tbl record;\n        seq_name text;\n        new_seq_name text;\n        archive_table_name text;\n    begin\n        -- No tables should be owned by the extension.\n        -- We want them to be included in logical backups\n        for tbl in\n            select c.relname as table_name\n            from pg_class c\n              join pg_depend d\n                on c.oid = d.objid\n              join pg_extension e\n                on d.refobjid = e.oid\n            where\n              c.relkind in ('r', 'p', 'u')\n              and e.extname = 'pgmq'\n              and (c.relname like 'q\\_%' or c.relname like 'a\\_%')\n        loop\n          execute format('\n            alter extension pgmq drop table pgmq.\"%s\";',\n            tbl.table_name\n          );\n        end loop;\n    end $$",
    "rolname": "supabase_admin",
    "calls": 66,
    "mean_time": 63.2629533181818,
    "min_time": 2.106425,
    "max_time": 98.206467,
    "total_time": 4175.354919,
    "rows_read": 0,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 2.4608794276879236,
    "index_advisor_result": null
  },
  {
    "query": "INSERT INTO \"refresh_tokens\" (\"created_at\", \"instance_id\", \"parent\", \"revoked\", \"session_id\", \"token\", \"updated_at\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8) returning id",
    "rolname": "supabase_auth_admin",
    "calls": 431,
    "mean_time": 8.32653274477959,
    "min_time": 0.11299,
    "max_time": 37.719962,
    "total_time": 3588.735613,
    "rows_read": 431,
    "cache_hit_rate": "99.9912952646239554",
    "prop_total_time": 2.115136512408829,
    "index_advisor_result": null
  },
  {
    "query": "SELECT\n    tbl.schemaname,\n    tbl.tablename,\n    tbl.quoted_name,\n    tbl.is_table,\n    json_agg(a) as columns\n  FROM\n    (\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $1 || quote_ident(c.relname)) as quoted_name,\n        $2 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind = $3\n        AND n.nspname not in ($4, $5, $6)\n        AND n.nspname not like $7\n        AND n.nspname not like $8\n        AND has_schema_privilege(n.oid, $9) = $10\n        AND has_table_privilege(quote_ident(n.nspname) || $11 || quote_ident(c.relname), $12) = $13\n      union all\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $14 || quote_ident(c.relname)) as quoted_name,\n        $15 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind in ($16, $17)\n        AND n.nspname not in ($18, $19, $20)\n        AND n.nspname not like $21\n        AND n.nspname not like $22\n        AND has_schema_privilege(n.oid, $23) = $24\n        AND has_table_privilege(quote_ident(n.nspname) || $25 || quote_ident(c.relname), $26) = $27\n    ) as tbl\n    LEFT JOIN (\n      SELECT\n        attrelid,\n        attname,\n        format_type(atttypid, atttypmod) as data_type,\n        attnum,\n        attisdropped\n      FROM\n        pg_attribute\n    ) as a ON (\n      a.attrelid = tbl.quoted_name::regclass\n      AND a.attnum > $28\n      AND NOT a.attisdropped\n      AND has_column_privilege(tbl.quoted_name, a.attname, $29)\n    )\n  \n  GROUP BY schemaname, tablename, quoted_name, is_table",
    "rolname": "postgres",
    "calls": 108,
    "mean_time": 28.087695712963,
    "min_time": 4.680489,
    "max_time": 638.28118,
    "total_time": 3033.471137,
    "rows_read": 5182,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 1.7878735725096795,
    "index_advisor_result": null
  },
  {
    "query": "with tables as (\nSELECT\n  c.oid :: int8 AS id,\n  nc.nspname AS schema,\n  c.relname AS name,\n  c.relrowsecurity AS rls_enabled,\n  c.relforcerowsecurity AS rls_forced,\n  CASE\n    WHEN c.relreplident = $1 THEN $2\n    WHEN c.relreplident = $3 THEN $4\n    WHEN c.relreplident = $5 THEN $6\n    ELSE $7\n  END AS replica_identity,\n  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,\n  pg_size_pretty(\n    pg_total_relation_size(format($9, nc.nspname, c.relname))\n  ) AS size,\n  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,\n  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,\n  obj_description(c.oid) AS comment,\n  coalesce(pk.primary_keys, $10) as primary_keys,\n  coalesce(\n    jsonb_agg(relationships) filter (where relationships is not null),\n    $11\n  ) as relationships\nFROM\n  pg_namespace nc\n  JOIN pg_class c ON nc.oid = c.relnamespace\n  left join (\n    select\n      c.oid::int8 as table_id,\n      jsonb_agg(\n        jsonb_build_object(\n          $12, c.oid::int8,\n          $13, n.nspname,\n          $14, c.relname,\n          $15, a.attname\n        )\n        order by array_position(i.indkey, a.attnum)\n      ) as primary_keys\n    from\n      pg_index i\n      join pg_class c on i.indrelid = c.oid\n      join pg_namespace n on c.relnamespace = n.oid\n      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)\n    where\n      n.nspname IN ($16) AND\n      \n      i.indisprimary\n    group by c.oid\n  ) as pk\n  on pk.table_id = c.oid\n  left join (\n    select\n      c.oid :: int8 as id,\n      c.conname as constraint_name,\n      nsa.nspname as source_schema,\n      csa.relname as source_table_name,\n      sa.attname as source_column_name,\n      nta.nspname as target_table_schema,\n      cta.relname as target_table_name,\n      ta.attname as target_column_name\n    from\n      pg_constraint c\n    join (\n      pg_attribute sa\n      join pg_class csa on sa.attrelid = csa.oid\n      join pg_namespace nsa on csa.relnamespace = nsa.oid\n    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)\n    join (\n      pg_attribute ta\n      join pg_class cta on ta.attrelid = cta.oid\n      join pg_namespace nta on cta.relnamespace = nta.oid\n    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)\n    where\n      nsa.nspname IN ($17) OR nta.nspname IN ($18) AND\n      \n      c.contype = $19\n  ) as relationships\n  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)\n  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)\nWHERE\n  nc.nspname IN ($20) AND\n  \n  \n  c.relkind IN ($21, $22)\n  AND NOT pg_is_other_temp_schema(nc.oid)\n  AND (\n    pg_has_role(c.relowner, $23)\n    OR has_table_privilege(\n      c.oid,\n      $24\n    )\n    OR has_any_column_privilege(c.oid, $25)\n  )\ngroup by\n  c.oid,\n  c.relname,\n  c.relrowsecurity,\n  c.relforcerowsecurity,\n  c.relreplident,\n  nc.nspname,\n  pk.primary_keys\n\n\n)\n  , columns as (\n-- Adapted from information_schema.columns\n\nSELECT\n  c.oid :: int8 AS table_id,\n  nc.nspname AS schema,\n  c.relname AS table,\n  (c.oid || $26 || a.attnum) AS id,\n  a.attnum AS ordinal_position,\n  a.attname AS name,\n  CASE\n    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)\n    ELSE $27\n  END AS default_value,\n  CASE\n    WHEN t.typtype = $28 THEN CASE\n      WHEN bt.typelem <> $29 :: oid\n      AND bt.typlen = $30 THEN $31\n      WHEN nbt.nspname = $32 THEN format_type(t.typbasetype, $33)\n      ELSE $34\n    END\n    ELSE CASE\n      WHEN t.typelem <> $35 :: oid\n      AND t.typlen = $36 THEN $37\n      WHEN nt.nspname = $38 THEN format_type(a.atttypid, $39)\n      ELSE $40\n    END\n  END AS data_type,\n  COALESCE(bt.typname, t.typname) AS format,\n  a.attidentity IN ($41, $42) AS is_identity,\n  CASE\n    a.attidentity\n    WHEN $43 THEN $44\n    WHEN $45 THEN $46\n    ELSE $47\n  END AS identity_generation,\n  a.attgenerated IN ($48) AS is_generated,\n  NOT (\n    a.attnotnull\n    OR t.typtype = $49 AND t.typnotnull\n  ) AS is_nullable,\n  (\n    c.relkind IN ($50, $51)\n    OR c.relkind IN ($52, $53) AND pg_column_is_updatable(c.oid, a.attnum, $54)\n  ) AS is_updatable,\n  uniques.table_id IS NOT NULL AS is_unique,\n  check_constraints.definition AS \"check\",\n  array_to_json(\n    array(\n      SELECT\n        enumlabel\n      FROM\n        pg_catalog.pg_enum enums\n      WHERE\n        enums.enumtypid = coalesce(bt.oid, t.oid)\n        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)\n      ORDER BY\n        enums.enumsortorder\n    )\n  ) AS enums,\n  col_description(c.oid, a.attnum) AS comment\nFROM\n  pg_attribute a\n  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid\n  AND a.attnum = ad.adnum\n  JOIN (\n    pg_class c\n    JOIN pg_namespace nc ON c.relnamespace = nc.oid\n  ) ON a.attrelid = c.oid\n  JOIN (\n    pg_type t\n    JOIN pg_namespace nt ON t.typnamespace = nt.oid\n  ) ON a.atttypid = t.oid\n  LEFT JOIN (\n    pg_type bt\n    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid\n  ) ON t.typtype = $55\n  AND t.typbasetype = bt.oid\n  LEFT JOIN (\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$56] AS ordinal_position\n    FROM pg_catalog.pg_constraint\n    WHERE contype = $57 AND cardinality(conkey) = $58\n  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum\n  LEFT JOIN (\n    -- We only select the first column check\n    SELECT DISTINCT ON (table_id, ordinal_position)\n      conrelid AS table_id,\n      conkey[$59] AS ordinal_position,\n      substring(\n        pg_get_constraintdef(pg_constraint.oid, $60),\n        $61,\n        length(pg_get_constraintdef(pg_constraint.oid, $62)) - $63\n      ) AS \"definition\"\n    FROM pg_constraint\n    WHERE contype = $64 AND cardinality(conkey) = $65\n    ORDER BY table_id, ordinal_position, oid asc\n  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum\nWHERE\n  nc.nspname IN ($66) AND\n  \n  \n  \n  \n  NOT pg_is_other_temp_schema(nc.oid)\n  AND a.attnum > $67\n  AND NOT a.attisdropped\n  AND (c.relkind IN ($68, $69, $70, $71, $72))\n  AND (\n    pg_has_role(c.relowner, $73)\n    OR has_column_privilege(\n      c.oid,\n      a.attnum,\n      $74\n    )\n  )\n\n\n)\nselect\n  *\n  , \nCOALESCE(\n  (\n    SELECT\n      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)\n    FROM\n      columns\n  ),\n  $75\n) AS columns\nfrom tables",
    "rolname": "postgres",
    "calls": 62,
    "mean_time": 48.4030037419355,
    "min_time": 24.027446,
    "max_time": 107.568957,
    "total_time": 3000.986232,
    "rows_read": 982,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 1.7687275511592258,
    "index_advisor_result": null
  },
  {
    "query": "SELECT t.oid, t.typname, t.typsend, t.typreceive, t.typoutput, t.typinput,\n       coalesce(d.typelem, t.typelem), coalesce(r.rngsubtype, $1), ARRAY (\n  SELECT a.atttypid\n  FROM pg_attribute AS a\n  WHERE a.attrelid = t.typrelid AND a.attnum > $2 AND NOT a.attisdropped\n  ORDER BY a.attnum\n)\n\nFROM pg_type AS t\nLEFT JOIN pg_type AS d ON t.typbasetype = d.oid\nLEFT JOIN pg_range AS r ON r.rngtypid = t.oid OR r.rngmultitypid = t.oid OR (t.typbasetype <> $3 AND r.rngtypid = t.typbasetype)\nWHERE (t.typrelid = $4)\nAND (t.typelem = $5 OR NOT EXISTS (SELECT $6 FROM pg_catalog.pg_type s WHERE s.typrelid != $7 AND s.oid = t.typelem))",
    "rolname": "supabase_admin",
    "calls": 99,
    "mean_time": 30.1323365050505,
    "min_time": 4.478927,
    "max_time": 243.595387,
    "total_time": 2983.101314,
    "rows_read": 21659,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 1.7581865007273676,
    "index_advisor_result": null
  },
  {
    "query": "INSERT INTO \"audit_log_entries\" (\"created_at\", \"id\", \"instance_id\", \"ip_address\", \"payload\") VALUES ($1, $2, $3, $4, $5)",
    "rolname": "supabase_auth_admin",
    "calls": 678,
    "mean_time": 4.04139905457227,
    "min_time": 0.017911,
    "max_time": 20.179863,
    "total_time": 2740.068559,
    "rows_read": 678,
    "cache_hit_rate": "99.9855835075326173",
    "prop_total_time": 1.6149473465389954,
    "index_advisor_result": null
  },
  {
    "query": "select setting from pg_config where name = $1",
    "rolname": "supabase_admin",
    "calls": 8212,
    "mean_time": 0.319993699464199,
    "min_time": 0.036234,
    "max_time": 10.270506,
    "total_time": 2627.78826,
    "rows_read": 8212,
    "cache_hit_rate": "0",
    "prop_total_time": 1.5487713487366517,
    "index_advisor_result": null
  },
  {
    "query": "CREATE OR REPLACE FUNCTION pg_temp.count_estimate(\n    query text\n) RETURNS integer LANGUAGE plpgsql AS $$\nDECLARE\n    plan jsonb;\nBEGIN\n    EXECUTE 'EXPLAIN (FORMAT JSON)' || query INTO plan;\n    RETURN plan->0->'Plan'->'Plan Rows';\nEND;\n$$",
    "rolname": "postgres",
    "calls": 116,
    "mean_time": 21.1190056551724,
    "min_time": 2.489492,
    "max_time": 138.629317,
    "total_time": 2449.804656,
    "rows_read": 0,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 1.4438709994139516,
    "index_advisor_result": null
  },
  {
    "query": "WITH pgrst_source AS ( SELECT \"public\".\"service_product_links\".\"product_id\", \"public\".\"service_product_links\".\"usage_per_vehicle\", \"public\".\"service_product_links\".\"dilution_ratio\", \"public\".\"service_product_links\".\"container_size\" FROM \"public\".\"service_product_links\" WHERE  \"public\".\"service_product_links\".\"service_id\" = $1   LIMIT $2 OFFSET $3 )  SELECT $4::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $5) AS body, nullif(current_setting($6, $7), $8) AS response_headers, nullif(current_setting($9, $10), $11) AS response_status, $12 AS response_inserted FROM ( SELECT * FROM pgrst_source ) _postgrest_t",
    "rolname": "authenticated",
    "calls": 9477,
    "mean_time": 0.227959804262952,
    "min_time": 0.008689,
    "max_time": 24.666344,
    "total_time": 2160.37506500001,
    "rows_read": 9477,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 1.2732863808429897,
    "index_advisor_result": null
  },
  {
    "query": "CREATE TYPE pg_temp.tabledefs AS ENUM('PKEY_INTERNAL','PKEY_EXTERNAL','FKEYS_INTERNAL','FKEYS_EXTERNAL','COMMENTS','FKEYS_NONE','INCLUDE_TRIGGERS','NO_TRIGGERS')",
    "rolname": "postgres",
    "calls": 124,
    "mean_time": 14.7259435564516,
    "min_time": 0.96013,
    "max_time": 625.695535,
    "total_time": 1826.017001,
    "rows_read": 0,
    "cache_hit_rate": "99.9908845066998876",
    "prop_total_time": 1.0762217247499333,
    "index_advisor_result": null
  },
  {
    "query": "SELECT\n  pol.oid :: int8 AS id,\n  n.nspname AS schema,\n  c.relname AS table,\n  c.oid :: int8 AS table_id,\n  pol.polname AS name,\n  CASE\n    WHEN pol.polpermissive THEN $1 :: text\n    ELSE $2 :: text\n  END AS action,\n  CASE\n    WHEN pol.polroles = $3 :: oid [] THEN array_to_json(\n      string_to_array($4 :: text, $5 :: text) :: name []\n    )\n    ELSE array_to_json(\n      ARRAY(\n        SELECT\n          pg_roles.rolname\n        FROM\n          pg_roles\n        WHERE\n          pg_roles.oid = ANY (pol.polroles)\n        ORDER BY\n          pg_roles.rolname\n      )\n    )\n  END AS roles,\n  CASE\n    pol.polcmd\n    WHEN $6 :: \"char\" THEN $7 :: text\n    WHEN $8 :: \"char\" THEN $9 :: text\n    WHEN $10 :: \"char\" THEN $11 :: text\n    WHEN $12 :: \"char\" THEN $13 :: text\n    WHEN $14 :: \"char\" THEN $15 :: text\n    ELSE $16 :: text\n  END AS command,\n  pg_get_expr(pol.polqual, pol.polrelid) AS definition,\n  pg_get_expr(pol.polwithcheck, pol.polrelid) AS check\nFROM\n  pg_policy pol\n  JOIN pg_class c ON c.oid = pol.polrelid\n  LEFT JOIN pg_namespace n ON n.oid = c.relnamespace\nWHERE\n  n.nspname NOT IN ($17,$18,$19)",
    "rolname": "postgres",
    "calls": 236,
    "mean_time": 7.6355781440678,
    "min_time": 0.841952,
    "max_time": 76.474236,
    "total_time": 1801.996442,
    "rows_read": 14455,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 1.0620644373740324,
    "index_advisor_result": null
  }
]